// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_AccuracyDOption
#include <AccuracyDOption.h>
#endif
#ifndef INCLUDED_AccuracyOption
#include <AccuracyOption.h>
#endif
#ifndef INCLUDED_AntialiasingOption
#include <AntialiasingOption.h>
#endif
#ifndef INCLUDED_BadMsOption
#include <BadMsOption.h>
#endif
#ifndef INCLUDED_BotPlay
#include <BotPlay.h>
#endif
#ifndef INCLUDED_CamZoomOption
#include <CamZoomOption.h>
#endif
#ifndef INCLUDED_Colour
#include <Colour.h>
#endif
#ifndef INCLUDED_Controls
#include <Controls.h>
#endif
#ifndef INCLUDED_CpuStrums
#include <CpuStrums.h>
#endif
#ifndef INCLUDED_CustomizeGameplay
#include <CustomizeGameplay.h>
#endif
#ifndef INCLUDED_DFJKOption
#include <DFJKOption.h>
#endif
#ifndef INCLUDED_Debug
#include <Debug.h>
#endif
#ifndef INCLUDED_DistractionsAndEffectsOption
#include <DistractionsAndEffectsOption.h>
#endif
#ifndef INCLUDED_DownKeybind
#include <DownKeybind.h>
#endif
#ifndef INCLUDED_DownscrollOption
#include <DownscrollOption.h>
#endif
#ifndef INCLUDED_EditorRes
#include <EditorRes.h>
#endif
#ifndef INCLUDED_FPSCapOption
#include <FPSCapOption.h>
#endif
#ifndef INCLUDED_FPSOption
#include <FPSOption.h>
#endif
#ifndef INCLUDED_FlashingLightsOption
#include <FlashingLightsOption.h>
#endif
#ifndef INCLUDED_FullscreenBind
#include <FullscreenBind.h>
#endif
#ifndef INCLUDED_GhostTapOption
#include <GhostTapOption.h>
#endif
#ifndef INCLUDED_GoodMsOption
#include <GoodMsOption.h>
#endif
#ifndef INCLUDED_HealthBarOption
#include <HealthBarOption.h>
#endif
#ifndef INCLUDED_InstantRespawn
#include <InstantRespawn.h>
#endif
#ifndef INCLUDED_Judgement
#include <Judgement.h>
#endif
#ifndef INCLUDED_JudgementCounter
#include <JudgementCounter.h>
#endif
#ifndef INCLUDED_LaneUnderlayOption
#include <LaneUnderlayOption.h>
#endif
#ifndef INCLUDED_LeftKeybind
#include <LeftKeybind.h>
#endif
#ifndef INCLUDED_LockWeeksOption
#include <LockWeeksOption.h>
#endif
#ifndef INCLUDED_MainMenuState
#include <MainMenuState.h>
#endif
#ifndef INCLUDED_MiddleScrollOption
#include <MiddleScrollOption.h>
#endif
#ifndef INCLUDED_MissSoundsOption
#include <MissSoundsOption.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_MusicBeatSubstate
#include <MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_MuteBind
#include <MuteBind.h>
#endif
#ifndef INCLUDED_NPSDisplayOption
#include <NPSDisplayOption.h>
#endif
#ifndef INCLUDED_NoteskinOption
#include <NoteskinOption.h>
#endif
#ifndef INCLUDED_OffsetThing
#include <OffsetThing.h>
#endif
#ifndef INCLUDED_Option
#include <Option.h>
#endif
#ifndef INCLUDED_OptionCata
#include <OptionCata.h>
#endif
#ifndef INCLUDED_OptionsMenu
#include <OptionsMenu.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PauseKeybind
#include <PauseKeybind.h>
#endif
#ifndef INCLUDED_PauseSubState
#include <PauseSubState.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_PlayStateChangeables
#include <PlayStateChangeables.h>
#endif
#ifndef INCLUDED_PlayerSettings
#include <PlayerSettings.h>
#endif
#ifndef INCLUDED_RainbowFPSOption
#include <RainbowFPSOption.h>
#endif
#ifndef INCLUDED_Ratings
#include <Ratings.h>
#endif
#ifndef INCLUDED_ResetBind
#include <ResetBind.h>
#endif
#ifndef INCLUDED_ResetButtonOption
#include <ResetButtonOption.h>
#endif
#ifndef INCLUDED_ResetScoreOption
#include <ResetScoreOption.h>
#endif
#ifndef INCLUDED_ResetSettings
#include <ResetSettings.h>
#endif
#ifndef INCLUDED_RightKeybind
#include <RightKeybind.h>
#endif
#ifndef INCLUDED_ScoreScreen
#include <ScoreScreen.h>
#endif
#ifndef INCLUDED_ScrollSpeedOption
#include <ScrollSpeedOption.h>
#endif
#ifndef INCLUDED_ShitMsOption
#include <ShitMsOption.h>
#endif
#ifndef INCLUDED_ShowInput
#include <ShowInput.h>
#endif
#ifndef INCLUDED_SickMSOption
#include <SickMSOption.h>
#endif
#ifndef INCLUDED_SongPositionOption
#include <SongPositionOption.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StepManiaOption
#include <StepManiaOption.h>
#endif
#ifndef INCLUDED_UpKeybind
#include <UpKeybind.h>
#endif
#ifndef INCLUDED_VolDownBind
#include <VolDownBind.h>
#endif
#ifndef INCLUDED_VolUpBind
#include <VolUpBind.h>
#endif
#ifndef INCLUDED_WatermarkOption
#include <WatermarkOption.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionSet
#include <flixel/input/actions/FlxActionSet.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadButton
#include <flixel/input/gamepad/FlxGamepadButton.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad__FlxGamepadInputID_FlxGamepadInputID_Impl_
#include <flixel/input/gamepad/_FlxGamepadInputID/FlxGamepadInputID_Impl_.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxBaseGamepadList
#include <flixel/input/gamepad/lists/FlxBaseGamepadList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadButtonList
#include <flixel/input/gamepad/lists/FlxGamepadButtonList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard__FlxKey_FlxKey_Impl_
#include <flixel/input/keyboard/_FlxKey/FlxKey_Impl_.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSoundGroup
#include <flixel/system/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_CameraFrontEnd
#include <flixel/system/frontEnds/CameraFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b7c1b117f8362d86_82_new,"OptionsMenu","new",0x0f1d276f,"OptionsMenu.new","OptionsMenu.hx",82,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_118_create,"OptionsMenu","create",0x9c60a34d,"OptionsMenu.create","OptionsMenu.hx",118,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_244_switchCat,"OptionsMenu","switchCat",0x14dc1ed1,"OptionsMenu.switchCat","OptionsMenu.hx",244,0x7ae6dae1)
static const int _hx_array_data_5da343fd_9[] = {
	(int)114,(int)640,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_323_selectOption,"OptionsMenu","selectOption",0xf2e396a2,"OptionsMenu.selectOption","OptionsMenu.hx",323,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_340_update,"OptionsMenu","update",0xa756c25a,"OptionsMenu.update","OptionsMenu.hx",340,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_99_boot,"OptionsMenu","boot",0x227e5a43,"OptionsMenu.boot","OptionsMenu.hx",99,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_103_boot,"OptionsMenu","boot",0x227e5a43,"OptionsMenu.boot","OptionsMenu.hx",103,0x7ae6dae1)
static const int _hx_array_data_5da343fd_23[] = {
	(int)114,(int)640,
};

void OptionsMenu_obj::__construct(::hx::Null< bool >  __o_pauseMenu){
            		bool pauseMenu = __o_pauseMenu.Default(false);
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_82_new)
HXLINE(  95)		this->isInCat = false;
HXLINE(  93)		this->selectedOptionIndex = 0;
HXLINE(  92)		this->selectedCatIndex = 0;
HXLINE( 107)		super::__construct(null());
HXLINE( 109)		::OptionsMenu_obj::isInPause = pauseMenu;
            	}

Dynamic OptionsMenu_obj::__CreateEmpty() { return new OptionsMenu_obj; }

void *OptionsMenu_obj::_hx_vtable = 0;

Dynamic OptionsMenu_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< OptionsMenu_obj > _hx_result = new OptionsMenu_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool OptionsMenu_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x5661ffbf) {
			if (inClassId<=(int)0x109e893d) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x109e893d;
			} else {
				return inClassId==(int)0x5661ffbf;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void OptionsMenu_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_118_create)
HXLINE( 121)		 ::ScrollSpeedOption _hx_tmp =  ::ScrollSpeedOption_obj::__alloc( HX_CTX ,HX_("Change your scroll speed. (1 = Chart dependent)",e3,c8,3b,f4));
HXLINE( 122)		 ::OffsetThing _hx_tmp1 =  ::OffsetThing_obj::__alloc( HX_CTX ,HX_("Change the note audio offset (how many milliseconds a note is offset in a chart)",50,8d,da,1b));
HXLINE( 123)		 ::AccuracyDOption _hx_tmp2 =  ::AccuracyDOption_obj::__alloc( HX_CTX ,HX_("Change how accuracy is calculated. (Accurate = Simple, Complex = Milisecond Based)",8a,fa,fc,fc));
HXLINE( 124)		 ::GhostTapOption _hx_tmp3 =  ::GhostTapOption_obj::__alloc( HX_CTX ,HX_("Toggle counting pressing a directional input when no arrow is there as a miss.",5c,fb,41,24));
HXLINE( 125)		 ::DownscrollOption _hx_tmp4 =  ::DownscrollOption_obj::__alloc( HX_CTX ,HX_("Toggle making the notes scroll down rather than up.",62,e3,85,ac));
HXLINE( 126)		 ::BotPlay _hx_tmp5 =  ::BotPlay_obj::__alloc( HX_CTX ,HX_("A bot plays for you!",92,28,7d,a3));
HXLINE( 127)		 ::FPSCapOption _hx_tmp6 =  ::FPSCapOption_obj::__alloc( HX_CTX ,HX_("Change your FPS Cap.",30,89,18,22));
HXLINE( 129)		 ::ResetButtonOption _hx_tmp7 =  ::ResetButtonOption_obj::__alloc( HX_CTX ,HX_("Toggle pressing R to gameover.",26,82,70,70));
HXLINE( 130)		 ::InstantRespawn _hx_tmp8 =  ::InstantRespawn_obj::__alloc( HX_CTX ,HX_("Toggle if you instantly respawn after dying.",e7,09,30,0b));
HXLINE( 131)		 ::CamZoomOption _hx_tmp9 =  ::CamZoomOption_obj::__alloc( HX_CTX ,HX_("Toggle the camera zoom in-game.",41,70,6b,49));
HXLINE( 133)		 ::DFJKOption _hx_tmp10 =  ::DFJKOption_obj::__alloc( HX_CTX );
HXLINE( 134)		 ::Judgement _hx_tmp11 =  ::Judgement_obj::__alloc( HX_CTX ,HX_("Create a custom judgement preset",f6,19,06,7d));
HXLINE( 120)		 ::OptionCata _hx_tmp12 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(50) ),( (Float)(40) ),HX_("Gameplay",06,bf,58,a5),::Array_obj< ::Dynamic>::__new(13)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,_hx_tmp2)->init(3,_hx_tmp3)->init(4,_hx_tmp4)->init(5,_hx_tmp5)->init(6,_hx_tmp6)->init(7,_hx_tmp7)->init(8,_hx_tmp8)->init(9,_hx_tmp9)->init(10,_hx_tmp10)->init(11,_hx_tmp11)->init(12, ::CustomizeGameplay_obj::__alloc( HX_CTX ,HX_("Drag and drop gameplay modules to your prefered positions!",09,7c,12,52))),null());
HXLINE( 138)		 ::NoteskinOption _hx_tmp13 =  ::NoteskinOption_obj::__alloc( HX_CTX ,HX_("Change your current noteskin",b3,76,62,eb));
HXDLIN( 138)		 ::EditorRes _hx_tmp14 =  ::EditorRes_obj::__alloc( HX_CTX ,HX_("Not showing the editor grid will greatly increase editor performance",c5,3a,66,7d));
HXLINE( 139)		 ::DistractionsAndEffectsOption _hx_tmp15 =  ::DistractionsAndEffectsOption_obj::__alloc( HX_CTX ,HX_("Toggle stage distractions that can hinder your gameplay.",0f,37,95,93));
HXLINE( 140)		 ::MiddleScrollOption _hx_tmp16 =  ::MiddleScrollOption_obj::__alloc( HX_CTX ,HX_("Put your lane in the center or on the right.",de,1b,73,d4));
HXDLIN( 140)		 ::HealthBarOption _hx_tmp17 =  ::HealthBarOption_obj::__alloc( HX_CTX ,HX_("Toggles health bar visibility",62,7b,8c,5e));
HXLINE( 141)		 ::JudgementCounter _hx_tmp18 =  ::JudgementCounter_obj::__alloc( HX_CTX ,HX_("Show your judgements that you've gotten in the song",98,0d,d9,36));
HXLINE( 142)		 ::LaneUnderlayOption _hx_tmp19 =  ::LaneUnderlayOption_obj::__alloc( HX_CTX ,HX_("How transparent your lane is, higher = more visible.",56,81,14,0a));
HXLINE( 143)		 ::StepManiaOption _hx_tmp20 =  ::StepManiaOption_obj::__alloc( HX_CTX ,HX_("Sets the colors of the arrows depending on quantization instead of direction.",42,78,c9,33));
HXLINE( 144)		 ::AccuracyOption _hx_tmp21 =  ::AccuracyOption_obj::__alloc( HX_CTX ,HX_("Display accuracy information on the info bar.",ba,58,cc,a4));
HXLINE( 145)		 ::SongPositionOption _hx_tmp22 =  ::SongPositionOption_obj::__alloc( HX_CTX ,HX_("Show the song's current position as a scrolling bar.",f0,c0,8f,57));
HXLINE( 146)		 ::Colour _hx_tmp23 =  ::Colour_obj::__alloc( HX_CTX ,HX_("The color behind icons now fit with their theme. (e.g. Pico = green)",e8,88,59,43));
HXLINE( 147)		 ::NPSDisplayOption _hx_tmp24 =  ::NPSDisplayOption_obj::__alloc( HX_CTX ,HX_("Shows your current Notes Per Second on the info bar.",bd,d5,04,b5));
HXLINE( 148)		 ::RainbowFPSOption _hx_tmp25 =  ::RainbowFPSOption_obj::__alloc( HX_CTX ,HX_("Make the FPS Counter flicker through rainbow colors.",b5,8f,ba,93));
HXLINE( 137)		 ::OptionCata _hx_tmp26 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(345) ),( (Float)(40) ),HX_("Appearance",04,ca,4d,37),::Array_obj< ::Dynamic>::__new(14)->init(0,_hx_tmp13)->init(1,_hx_tmp14)->init(2,_hx_tmp15)->init(3,_hx_tmp16)->init(4,_hx_tmp17)->init(5,_hx_tmp18)->init(6,_hx_tmp19)->init(7,_hx_tmp20)->init(8,_hx_tmp21)->init(9,_hx_tmp22)->init(10,_hx_tmp23)->init(11,_hx_tmp24)->init(12,_hx_tmp25)->init(13, ::CpuStrums_obj::__alloc( HX_CTX ,HX_("Toggle the CPU's strumline lighting up when it hits a note.",87,6c,ad,f0))),null());
HXLINE( 152)		 ::FPSOption _hx_tmp27 =  ::FPSOption_obj::__alloc( HX_CTX ,HX_("Toggle the FPS Counter",ea,68,c5,9e));
HXLINE( 153)		 ::FlashingLightsOption _hx_tmp28 =  ::FlashingLightsOption_obj::__alloc( HX_CTX ,HX_("Toggle flashing lights that can cause epileptic seizures and strain.",c8,92,75,4d));
HXLINE( 154)		 ::WatermarkOption _hx_tmp29 =  ::WatermarkOption_obj::__alloc( HX_CTX ,HX_("Enable and disable all watermarks from the engine.",bb,b5,df,79));
HXLINE( 155)		 ::AntialiasingOption _hx_tmp30 =  ::AntialiasingOption_obj::__alloc( HX_CTX ,HX_("Toggle antialiasing, improving graphics quality at a slight performance penalty.",7d,57,9f,0a));
HXLINE( 156)		 ::MissSoundsOption _hx_tmp31 =  ::MissSoundsOption_obj::__alloc( HX_CTX ,HX_("Toggle miss sounds playing when you don't hit a note.",6f,4d,eb,2e));
HXLINE( 157)		 ::ScoreScreen _hx_tmp32 =  ::ScoreScreen_obj::__alloc( HX_CTX ,HX_("Show the score screen after the end of a song",31,96,52,d3));
HXLINE( 151)		 ::OptionCata _hx_tmp33 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(640) ),( (Float)(40) ),HX_("Misc",0c,7f,35,33),::Array_obj< ::Dynamic>::__new(7)->init(0,_hx_tmp27)->init(1,_hx_tmp28)->init(2,_hx_tmp29)->init(3,_hx_tmp30)->init(4,_hx_tmp31)->init(5,_hx_tmp32)->init(6, ::ShowInput_obj::__alloc( HX_CTX ,HX_("Display every single input on the score screen.",ef,5f,8a,25))),null());
HXLINE( 163)		 ::ResetScoreOption _hx_tmp34 =  ::ResetScoreOption_obj::__alloc( HX_CTX ,HX_("Reset your score on all songs and weeks. This is irreversible!",ff,05,aa,41));
HXLINE( 164)		 ::LockWeeksOption _hx_tmp35 =  ::LockWeeksOption_obj::__alloc( HX_CTX ,HX_("Reset your story mode progress. This is irreversible!",1a,39,20,15));
HXLINE( 160)		 ::OptionCata _hx_tmp36 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(935) ),( (Float)(40) ),HX_("Saves",76,ba,b9,0a),::Array_obj< ::Dynamic>::__new(3)->init(0,_hx_tmp34)->init(1,_hx_tmp35)->init(2, ::ResetSettings_obj::__alloc( HX_CTX ,HX_("Reset ALL your settings. This is irreversible!",1d,80,bd,16))),null());
HXLINE( 168)		 ::LeftKeybind _hx_tmp37 =  ::LeftKeybind_obj::__alloc( HX_CTX ,HX_("The left note's keybind",44,52,a8,12));
HXDLIN( 168)		 ::DownKeybind _hx_tmp38 =  ::DownKeybind_obj::__alloc( HX_CTX ,HX_("The down note's keybind",49,00,37,a9));
HXDLIN( 168)		 ::UpKeybind _hx_tmp39 =  ::UpKeybind_obj::__alloc( HX_CTX ,HX_("The up note's keybind",30,74,5a,39));
HXLINE( 169)		 ::RightKeybind _hx_tmp40 =  ::RightKeybind_obj::__alloc( HX_CTX ,HX_("The right note's keybind",8d,0b,41,52));
HXDLIN( 169)		 ::PauseKeybind _hx_tmp41 =  ::PauseKeybind_obj::__alloc( HX_CTX ,HX_("The keybind used to pause the game",80,04,fc,ef));
HXLINE( 170)		 ::ResetBind _hx_tmp42 =  ::ResetBind_obj::__alloc( HX_CTX ,HX_("The keybind used to die instantly",59,b2,54,f7));
HXDLIN( 170)		 ::MuteBind _hx_tmp43 =  ::MuteBind_obj::__alloc( HX_CTX ,HX_("The keybind used to mute game audio",5a,d2,76,4c));
HXLINE( 171)		 ::VolUpBind _hx_tmp44 =  ::VolUpBind_obj::__alloc( HX_CTX ,HX_("The keybind used to turn the volume up",24,83,88,b1));
HXDLIN( 171)		 ::VolDownBind _hx_tmp45 =  ::VolDownBind_obj::__alloc( HX_CTX ,HX_("The keybind used to turn the volume down",6b,99,cd,7b));
HXLINE( 167)		 ::OptionCata _hx_tmp46 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(-1) ),( (Float)(125) ),HX_("Editing Keybinds",5f,f6,bc,a7),::Array_obj< ::Dynamic>::__new(10)->init(0,_hx_tmp37)->init(1,_hx_tmp38)->init(2,_hx_tmp39)->init(3,_hx_tmp40)->init(4,_hx_tmp41)->init(5,_hx_tmp42)->init(6,_hx_tmp43)->init(7,_hx_tmp44)->init(8,_hx_tmp45)->init(9, ::FullscreenBind_obj::__alloc( HX_CTX ,HX_("The keybind used to fullscreen the game",51,64,2d,68))),true);
HXLINE( 174)		 ::SickMSOption _hx_tmp47 =  ::SickMSOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the SICK hit window",9e,76,ad,4e));
HXLINE( 175)		 ::GoodMsOption _hx_tmp48 =  ::GoodMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the GOOD hit window",7f,d0,bb,5b));
HXLINE( 176)		 ::BadMsOption _hx_tmp49 =  ::BadMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the BAD hit window",39,99,1b,7b));
HXLINE( 119)		this->options = ::Array_obj< ::Dynamic>::__new(6)->init(0,_hx_tmp12)->init(1,_hx_tmp26)->init(2,_hx_tmp33)->init(3,_hx_tmp36)->init(4,_hx_tmp46)->init(5, ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(-1) ),( (Float)(125) ),HX_("Editing Judgements",66,64,14,2b),::Array_obj< ::Dynamic>::__new(4)->init(0,_hx_tmp47)->init(1,_hx_tmp48)->init(2,_hx_tmp49)->init(3, ::ShitMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the SHIT hit window",dc,ee,3d,7e))),true));
HXLINE( 181)		::OptionsMenu_obj::instance = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 183)		this->menu =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 185)		this->shownStuff =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 187)		this->background =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,50,40,null())->makeGraphic(1180,640,-16777216,null(),null());
HXLINE( 188)		this->background->set_alpha(((Float)0.5));
HXLINE( 189)		this->background->scrollFactor->set(null(),null());
HXLINE( 190)		this->menu->add(this->background).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 192)		this->descBack =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,50,640,null())->makeGraphic(1180,38,-16777216,null(),null());
HXLINE( 193)		this->descBack->set_alpha(((Float)0.3));
HXLINE( 194)		this->descBack->scrollFactor->set(null(),null());
HXLINE( 195)		this->menu->add(this->descBack).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 197)		if (::OptionsMenu_obj::isInPause) {
HXLINE( 199)			 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE( 200)			bg->set_alpha(( (Float)(0) ));
HXLINE( 201)			bg->scrollFactor->set(null(),null());
HXLINE( 202)			this->menu->add(bg).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 204)			this->background->set_alpha(((Float)0.5));
HXLINE( 205)			bg->set_alpha(((Float)0.6));
HXLINE( 207)			this->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,::flixel::FlxG_obj::cameras->list->__get((::flixel::FlxG_obj::cameras->list->length - 1)).StaticCast<  ::flixel::FlxCamera >()));
            		}
HXLINE( 210)		this->selectedCat = this->options->__get(0).StaticCast<  ::OptionCata >();
HXLINE( 212)		this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 214)		this->add(this->menu);
HXLINE( 216)		this->add(this->shownStuff);
HXLINE( 218)		{
HXLINE( 218)			int _g = 0;
HXDLIN( 218)			int _g1 = (this->options->length - 1);
HXDLIN( 218)			while((_g < _g1)){
HXLINE( 218)				_g = (_g + 1);
HXDLIN( 218)				int i = (_g - 1);
HXLINE( 220)				if ((i >= 4)) {
HXLINE( 221)					continue;
            				}
HXLINE( 222)				 ::OptionCata cat = this->options->__get(i).StaticCast<  ::OptionCata >();
HXLINE( 223)				this->add(cat);
HXLINE( 224)				this->add(cat->titleObject);
            			}
            		}
HXLINE( 227)		this->descText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,62,648,null(),null(),null(),null());
HXLINE( 228)		this->descText->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("vcr.ttf",9d,d2,a7,82)),20,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 229)		this->descText->set_borderSize(( (Float)(2) ));
HXLINE( 231)		this->add(this->descBack);
HXLINE( 232)		this->add(this->descText);
HXLINE( 234)		this->isInCat = true;
HXLINE( 236)		this->switchCat(this->selectedCat,null());
HXLINE( 238)		this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 240)		this->super::create();
            	}


void OptionsMenu_obj::switchCat( ::OptionCata cat,::hx::Null< bool >  __o_checkForOutOfBounds){
            		bool checkForOutOfBounds = __o_checkForOutOfBounds.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_244_switchCat)
HXLINE( 245)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 247)			::OptionsMenu_obj::visibleRange = ::Array_obj< int >::fromData( _hx_array_data_5da343fd_9,2);
HXLINE( 248)			if (cat->middle) {
HXLINE( 249)				::OptionsMenu_obj::visibleRange = ::Array_obj< int >::__new(2)->init(0,::Std_obj::_hx_int(cat->titleObject->y))->init(1,640);
            			}
HXLINE( 250)			if (::hx::IsNotNull( this->selectedOption )) {
HXLINE( 252)				 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 253)				object->set_text(this->selectedOption->getValue());
            			}
HXLINE( 256)			bool _hx_tmp;
HXDLIN( 256)			if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 256)				_hx_tmp = checkForOutOfBounds;
            			}
            			else {
HXLINE( 256)				_hx_tmp = false;
            			}
HXDLIN( 256)			if (_hx_tmp) {
HXLINE( 257)				this->selectedCatIndex = 0;
            			}
HXLINE( 259)			if (this->selectedCat->middle) {
HXLINE( 260)				this->remove(this->selectedCat->titleObject,null());
            			}
HXLINE( 262)			this->selectedCat->changeColor(-16777216);
HXLINE( 263)			this->selectedCat->set_alpha(((Float)0.3));
HXLINE( 265)			{
HXLINE( 265)				int _g = 0;
HXDLIN( 265)				int _g1 = this->selectedCat->options->length;
HXDLIN( 265)				while((_g < _g1)){
HXLINE( 265)					_g = (_g + 1);
HXDLIN( 265)					int i = (_g - 1);
HXLINE( 267)					 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 268)					opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            				}
            			}
HXLINE( 271)			while((this->shownStuff->members->get_length() != 0)){
HXLINE( 273)				this->shownStuff->members->remove(Dynamic( this->shownStuff->members->__get(0)).StaticCast<  ::flixel::text::FlxText >());
            			}
HXLINE( 275)			this->selectedCat = cat;
HXLINE( 276)			this->selectedCat->set_alpha(((Float)0.2));
HXLINE( 277)			this->selectedCat->changeColor(-1);
HXLINE( 279)			if (this->selectedCat->middle) {
HXLINE( 280)				this->add(this->selectedCat->titleObject);
            			}
HXLINE( 282)			{
HXLINE( 282)				 ::Dynamic filter = null();
HXDLIN( 282)				 ::flixel::group::FlxTypedGroupIterator i =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->selectedCat->optionObjects->members,filter);
HXDLIN( 282)				while(i->hasNext()){
HXLINE( 282)					 ::flixel::text::FlxText i1 = i->next().StaticCast<  ::flixel::text::FlxText >();
HXLINE( 283)					this->shownStuff->add(i1).StaticCast<  ::flixel::text::FlxText >();
            				}
            			}
HXLINE( 285)			this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 287)			if ((this->selectedOptionIndex > (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1))) {
HXLINE( 289)				int _g = 0;
HXDLIN( 289)				int _g1 = this->selectedCat->options->length;
HXDLIN( 289)				while((_g < _g1)){
HXLINE( 289)					_g = (_g + 1);
HXDLIN( 289)					int i = (_g - 1);
HXLINE( 291)					 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 292)					opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            				}
            			}
HXLINE( 296)			this->selectedOptionIndex = 0;
HXLINE( 298)			if (!(this->isInCat)) {
HXLINE( 299)				this->selectOption(this->selectedOption);
            			}
HXLINE( 301)			{
HXLINE( 301)				int _g2 = 0;
HXDLIN( 301)				::Array< ::Dynamic> _g3 = this->selectedCat->optionObjects->members;
HXDLIN( 301)				while((_g2 < _g3->length)){
HXLINE( 301)					 ::flixel::text::FlxText i = _g3->__get(_g2).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 301)					_g2 = (_g2 + 1);
HXLINE( 303)					if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 304)						i->set_alpha(( (Float)(0) ));
            					}
            					else {
HXLINE( 305)						if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 306)							i->set_alpha(( (Float)(0) ));
            						}
            						else {
HXLINE( 309)							i->set_alpha(((Float)0.4));
            						}
            					}
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 314)				{
HXLINE( 315)					{
HXLINE( 315)						 ::Dynamic input = (HX_("oops\n",87,73,2e,33) + ::Std_obj::string(e));
HXDLIN( 315)						if (::hx::IsNotNull( input )) {
HXLINE( 315)							::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),315,HX_("OptionsMenu",fd,43,a3,5d),HX_("switchCat",82,92,35,0e)));
HXDLIN( 315)							::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 315)							::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            						}
            					}
HXLINE( 316)					this->selectedCatIndex = 0;
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 319)		::Debug_obj::logTrace((HX_("Changed cat: ",f0,13,63,26) + this->selectedCatIndex),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),319,HX_("OptionsMenu",fd,43,a3,5d),HX_("switchCat",82,92,35,0e)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(OptionsMenu_obj,switchCat,(void))

void OptionsMenu_obj::selectOption( ::Option option){
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_323_selectOption)
HXLINE( 324)		 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 326)		this->selectedOption = option;
HXLINE( 328)		if (!(this->isInCat)) {
HXLINE( 330)			object->set_text((HX_("> ",22,36,00,00) + option->getValue()));
HXLINE( 332)			 ::flixel::text::FlxText _hx_tmp = this->descText;
HXDLIN( 332)			_hx_tmp->set_text(option->getDescription());
            		}
HXLINE( 334)		::Debug_obj::logTrace((HX_("Changed opt: ",4d,3d,1c,19) + this->selectedOptionIndex),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),334,HX_("OptionsMenu",fd,43,a3,5d),HX_("selectOption",91,c7,b2,0f)));
HXLINE( 336)		::Debug_obj::logTrace((((HX_("Bounds: ",7b,bc,15,27) + ::OptionsMenu_obj::visibleRange->__get(0)) + HX_(",",2c,00,00,00)) + ::OptionsMenu_obj::visibleRange->__get(1)),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),336,HX_("OptionsMenu",fd,43,a3,5d),HX_("selectOption",91,c7,b2,0f)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(OptionsMenu_obj,selectOption,(void))

void OptionsMenu_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_340_update)
HXLINE( 341)		this->super::update(elapsed);
HXLINE( 343)		 ::flixel::input::gamepad::FlxGamepad gamepad = ::flixel::FlxG_obj::gamepads->lastActive;
HXLINE( 345)		bool accept = false;
HXLINE( 346)		bool right = false;
HXLINE( 347)		bool left = false;
HXLINE( 348)		bool up = false;
HXLINE( 349)		bool down = false;
HXLINE( 350)		bool any = false;
HXLINE( 351)		bool escape = false;
HXLINE( 353)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 353)		if (!(_this->keyManager->checkStatus(13,_this->status))) {
HXLINE( 353)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 353)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 353)				int id = 0;
HXDLIN( 353)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 353)				int Status = _this->status;
HXDLIN( 353)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 353)						accept = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 353)						accept = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 353)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 353)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 353)						if (::hx::IsNotNull( button )) {
HXLINE( 353)							accept = button->hasState(Status);
            						}
            						else {
HXLINE( 353)							accept = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 353)				accept = false;
            			}
            		}
            		else {
HXLINE( 353)			accept = true;
            		}
HXLINE( 354)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 354)		if (!(_this1->keyManager->checkStatus(39,_this1->status))) {
HXLINE( 354)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 354)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 354)				int id = 14;
HXDLIN( 354)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 354)				int Status = _this->status;
HXDLIN( 354)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 354)						right = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 354)						right = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 354)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 354)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 354)						if (::hx::IsNotNull( button )) {
HXLINE( 354)							right = button->hasState(Status);
            						}
            						else {
HXLINE( 354)							right = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 354)				right = false;
            			}
            		}
            		else {
HXLINE( 354)			right = true;
            		}
HXLINE( 355)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 355)		if (!(_this2->keyManager->checkStatus(37,_this2->status))) {
HXLINE( 355)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 355)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 355)				int id = 13;
HXDLIN( 355)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 355)				int Status = _this->status;
HXDLIN( 355)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 355)						left = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 355)						left = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 355)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 355)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 355)						if (::hx::IsNotNull( button )) {
HXLINE( 355)							left = button->hasState(Status);
            						}
            						else {
HXLINE( 355)							left = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 355)				left = false;
            			}
            		}
            		else {
HXLINE( 355)			left = true;
            		}
HXLINE( 356)		 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 356)		if (!(_this3->keyManager->checkStatus(38,_this3->status))) {
HXLINE( 356)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 356)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 356)				int id = 11;
HXDLIN( 356)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 356)				int Status = _this->status;
HXDLIN( 356)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 356)						up = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 356)						up = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 356)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 356)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 356)						if (::hx::IsNotNull( button )) {
HXLINE( 356)							up = button->hasState(Status);
            						}
            						else {
HXLINE( 356)							up = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 356)				up = false;
            			}
            		}
            		else {
HXLINE( 356)			up = true;
            		}
HXLINE( 357)		 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 357)		if (!(_this4->keyManager->checkStatus(40,_this4->status))) {
HXLINE( 357)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 357)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 357)				int id = 12;
HXDLIN( 357)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 357)				int Status = _this->status;
HXDLIN( 357)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 357)						down = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 357)						down = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 357)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 357)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 357)						if (::hx::IsNotNull( button )) {
HXLINE( 357)							down = button->hasState(Status);
            						}
            						else {
HXLINE( 357)							down = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 357)				down = false;
            			}
            		}
            		else {
HXLINE( 357)			down = true;
            		}
HXLINE( 359)		if (!(( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justPressed) )->get_ANY())) {
HXLINE( 359)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 359)				any = gamepad->justPressed->get_ANY();
            			}
            			else {
HXLINE( 359)				any = false;
            			}
            		}
            		else {
HXLINE( 359)			any = true;
            		}
HXLINE( 360)		 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 360)		if (!(_this5->keyManager->checkStatus(27,_this5->status))) {
HXLINE( 360)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 360)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 360)				int id = 1;
HXDLIN( 360)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 360)				int Status = _this->status;
HXDLIN( 360)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 360)						escape = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 360)						escape = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 360)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 360)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 360)						if (::hx::IsNotNull( button )) {
HXLINE( 360)							escape = button->hasState(Status);
            						}
            						else {
HXLINE( 360)							escape = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 360)				escape = false;
            			}
            		}
            		else {
HXLINE( 360)			escape = true;
            		}
HXLINE( 362)		bool _hx_tmp;
HXDLIN( 362)		if (::hx::IsNotNull( this->selectedCat )) {
HXLINE( 362)			_hx_tmp = !(this->isInCat);
            		}
            		else {
HXLINE( 362)			_hx_tmp = false;
            		}
HXDLIN( 362)		if (_hx_tmp) {
HXLINE( 364)			int _g = 0;
HXDLIN( 364)			::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 364)			while((_g < _g1->length)){
HXLINE( 364)				 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 364)				_g = (_g + 1);
HXLINE( 366)				if (this->selectedCat->middle) {
HXLINE( 368)					i->screenCenter(::flixel::util::FlxAxes_obj::X_dyn());
            				}
HXLINE( 372)				if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 373)					i->set_alpha(( (Float)(0) ));
            				}
            				else {
HXLINE( 374)					if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 375)						i->set_alpha(( (Float)(0) ));
            					}
            					else {
HXLINE( 378)						if ((Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >()->text != i->text)) {
HXLINE( 379)							i->set_alpha(((Float)0.4));
            						}
            						else {
HXLINE( 381)							i->set_alpha(( (Float)(1) ));
            						}
            					}
            				}
            			}
            		}
HXLINE( 386)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 388)			if (this->isInCat) {
HXLINE( 390)				this->descText->set_text(HX_("Please select a category",ab,e3,01,d1));
HXLINE( 391)				if (right) {
HXLINE( 393)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 393)					_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 394)					 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 394)					_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 395)					this->selectedCatIndex++;
HXLINE( 397)					if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 398)						this->selectedCatIndex = 0;
            					}
HXLINE( 399)					if ((this->selectedCatIndex < 0)) {
HXLINE( 400)						this->selectedCatIndex = (this->options->length - 3);
            					}
HXLINE( 402)					this->switchCat(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >(),null());
            				}
            				else {
HXLINE( 404)					if (left) {
HXLINE( 406)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 406)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 407)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 407)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 408)						this->selectedCatIndex--;
HXLINE( 410)						if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 411)							this->selectedCatIndex = 0;
            						}
HXLINE( 412)						if ((this->selectedCatIndex < 0)) {
HXLINE( 413)							this->selectedCatIndex = (this->options->length - 3);
            						}
HXLINE( 415)						this->switchCat(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >(),null());
            					}
            				}
HXLINE( 418)				if (accept) {
HXLINE( 420)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 420)					_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 421)					this->selectedOptionIndex = 0;
HXLINE( 422)					this->isInCat = false;
HXLINE( 423)					this->selectOption(this->selectedCat->options->__get(0).StaticCast<  ::Option >());
            				}
HXLINE( 426)				if (escape) {
HXLINE( 428)					if (!(::OptionsMenu_obj::isInPause)) {
HXLINE( 429)						 ::flixel::FlxState nextState =  ::MainMenuState_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 429)						if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 429)							::flixel::FlxG_obj::game->_requestedState = nextState;
            						}
            					}
            					else {
HXLINE( 432)						::PauseSubState_obj::goBack = true;
HXLINE( 433)						::PlayStateChangeables_obj::scrollSpeed = (( (Float)(::flixel::FlxG_obj::save->data->__Field(HX_("scrollSpeed",3a,e0,46,cb),::hx::paccDynamic)) ) * ::PlayState_obj::songMultiplier);
HXLINE( 434)						this->close();
            					}
            				}
            			}
            			else {
HXLINE( 440)				if (::hx::IsNotNull( this->selectedOption )) {
HXLINE( 441)					if (this->selectedOption->acceptType) {
HXLINE( 443)						bool _hx_tmp;
HXDLIN( 443)						if (escape) {
HXLINE( 443)							_hx_tmp = this->selectedOption->waitingType;
            						}
            						else {
HXLINE( 443)							_hx_tmp = false;
            						}
HXDLIN( 443)						if (_hx_tmp) {
HXLINE( 445)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 445)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 446)							this->selectedOption->waitingType = false;
HXLINE( 447)							 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 448)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 449)							::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),449,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
HXLINE( 450)							return;
            						}
            						else {
HXLINE( 452)							if (any) {
HXLINE( 454)								 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 455)								 ::Option _hx_tmp = this->selectedOption;
HXDLIN( 455)								::String _hx_tmp1;
HXDLIN( 455)								if (::hx::IsNull( gamepad )) {
HXLINE( 455)									int this1 = ( (int)(::flixel::FlxG_obj::keys->getIsDown()->__get(0).StaticCast<  ::flixel::input::FlxInput >()->ID) );
HXDLIN( 455)									_hx_tmp1 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get_string(this1);
            								}
            								else {
HXLINE( 455)									 ::flixel::input::gamepad::mappings::FlxGamepadMapping gamepad1 = gamepad->mapping;
HXDLIN( 455)									int this1 = gamepad1->getID(gamepad->firstJustPressedRawID());
HXDLIN( 455)									_hx_tmp1 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(this1);
            								}
HXDLIN( 455)								_hx_tmp->onType(_hx_tmp1);
HXLINE( 456)								object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 457)								::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),457,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            							}
            						}
            					}
            				}
HXLINE( 460)				bool _hx_tmp;
HXDLIN( 460)				if (!(this->selectedOption->acceptType)) {
HXLINE( 460)					_hx_tmp = !(this->selectedOption->acceptType);
            				}
            				else {
HXLINE( 460)					_hx_tmp = true;
            				}
HXDLIN( 460)				if (_hx_tmp) {
HXLINE( 462)					if (accept) {
HXLINE( 464)						int prev = this->selectedOptionIndex;
HXLINE( 465)						 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 466)						this->selectedOption->press();
HXLINE( 468)						if ((this->selectedOptionIndex == prev)) {
HXLINE( 470)							::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 472)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
            						}
            					}
HXLINE( 476)					if (down) {
HXLINE( 478)						if (this->selectedOption->acceptType) {
HXLINE( 479)							this->selectedOption->waitingType = false;
            						}
HXLINE( 480)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 480)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 481)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 481)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 482)						this->selectedOptionIndex++;
HXLINE( 486)						if ((this->selectedOptionIndex > (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1))) {
HXLINE( 488)							{
HXLINE( 488)								int _g = 0;
HXDLIN( 488)								int _g1 = this->selectedCat->options->length;
HXDLIN( 488)								while((_g < _g1)){
HXLINE( 488)									_g = (_g + 1);
HXDLIN( 488)									int i = (_g - 1);
HXLINE( 490)									 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 491)									opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            								}
            							}
HXLINE( 493)							this->selectedOptionIndex = 0;
            						}
HXLINE( 496)						bool _hx_tmp2;
HXDLIN( 496)						bool _hx_tmp3;
HXDLIN( 496)						if ((this->selectedOptionIndex != 0)) {
HXLINE( 496)							_hx_tmp3 = (this->selectedOptionIndex != (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1));
            						}
            						else {
HXLINE( 496)							_hx_tmp3 = false;
            						}
HXDLIN( 496)						if (_hx_tmp3) {
HXLINE( 496)							_hx_tmp2 = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6);
            						}
            						else {
HXLINE( 496)							_hx_tmp2 = false;
            						}
HXDLIN( 496)						if (_hx_tmp2) {
HXLINE( 500)							if ((this->selectedOptionIndex >= (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 501)								int _g = 0;
HXDLIN( 501)								::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 501)								while((_g < _g1->length)){
HXLINE( 501)									 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 501)									_g = (_g + 1);
HXLINE( 503)									{
HXLINE( 503)										 ::flixel::text::FlxText _g2 = i;
HXDLIN( 503)										_g2->set_y((_g2->y - ( (Float)(46) )));
            									}
            								}
            							}
            						}
HXLINE( 507)						this->selectOption(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->__get(this->selectedOptionIndex).StaticCast<  ::Option >());
            					}
            					else {
HXLINE( 509)						if (up) {
HXLINE( 511)							if (this->selectedOption->acceptType) {
HXLINE( 512)								this->selectedOption->waitingType = false;
            							}
HXLINE( 513)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 513)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 514)							 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 514)							_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 515)							this->selectedOptionIndex--;
HXLINE( 519)							if ((this->selectedOptionIndex < 0)) {
HXLINE( 521)								this->selectedOptionIndex = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1);
HXLINE( 523)								if ((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6)) {
HXLINE( 524)									int _g = 0;
HXDLIN( 524)									::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 524)									while((_g < _g1->length)){
HXLINE( 524)										 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 524)										_g = (_g + 1);
HXLINE( 526)										{
HXLINE( 526)											 ::flixel::text::FlxText _g2 = i;
HXDLIN( 526)											_g2->set_y((_g2->y - (( (Float)(46) ) * (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))));
            										}
            									}
            								}
            							}
HXLINE( 530)							bool _hx_tmp2;
HXDLIN( 530)							if ((this->selectedOptionIndex != 0)) {
HXLINE( 530)								_hx_tmp2 = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6);
            							}
            							else {
HXLINE( 530)								_hx_tmp2 = false;
            							}
HXDLIN( 530)							if (_hx_tmp2) {
HXLINE( 532)								if ((this->selectedOptionIndex >= (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 533)									int _g = 0;
HXDLIN( 533)									::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 533)									while((_g < _g1->length)){
HXLINE( 533)										 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 533)										_g = (_g + 1);
HXLINE( 535)										{
HXLINE( 535)											 ::flixel::text::FlxText _g2 = i;
HXDLIN( 535)											_g2->set_y((_g2->y + 46));
            										}
            									}
            								}
            							}
HXLINE( 539)							if ((this->selectedOptionIndex < (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 541)								int _g = 0;
HXDLIN( 541)								int _g1 = this->selectedCat->options->length;
HXDLIN( 541)								while((_g < _g1)){
HXLINE( 541)									_g = (_g + 1);
HXDLIN( 541)									int i = (_g - 1);
HXLINE( 543)									 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 544)									opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            								}
            							}
HXLINE( 548)							this->selectOption(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->__get(this->selectedOptionIndex).StaticCast<  ::Option >());
            						}
            					}
HXLINE( 551)					if (right) {
HXLINE( 553)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 553)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 554)						 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 555)						this->selectedOption->right();
HXLINE( 557)						::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 559)						object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 560)						::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),560,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            					}
            					else {
HXLINE( 562)						if (left) {
HXLINE( 564)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 564)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 565)							 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 566)							this->selectedOption->left();
HXLINE( 568)							::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 570)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 571)							::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),571,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            						}
            					}
HXLINE( 574)					if (escape) {
HXLINE( 576)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 576)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 578)						if ((this->selectedCatIndex >= 4)) {
HXLINE( 579)							this->selectedCatIndex = 0;
            						}
HXLINE( 581)						::PlayerSettings_obj::player1->controls->loadKeyBinds();
HXLINE( 583)						::Ratings_obj::timingWindows = ::Array_obj< int >::__new(4)->init(0, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("shitMs",46,83,76,22),::hx::paccDynamic)))->init(1, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("badMs",8b,b0,ae,ad),::hx::paccDynamic)))->init(2, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("goodMs",03,62,e7,61),::hx::paccDynamic)))->init(3, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("sickMs",c4,fb,de,b1),::hx::paccDynamic)));
HXLINE( 590)						{
HXLINE( 590)							int _g = 0;
HXDLIN( 590)							int _g1 = this->selectedCat->options->length;
HXDLIN( 590)							while((_g < _g1)){
HXLINE( 590)								_g = (_g + 1);
HXDLIN( 590)								int i = (_g - 1);
HXLINE( 592)								 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 593)								opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            							}
            						}
HXLINE( 595)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 595)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 596)						this->isInCat = true;
HXLINE( 597)						if (::hx::IsNotNull( this->selectedCat->optionObjects )) {
HXLINE( 598)							int _g = 0;
HXDLIN( 598)							::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 598)							while((_g < _g1->length)){
HXLINE( 598)								 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 598)								_g = (_g + 1);
HXLINE( 600)								if (::hx::IsNotNull( i )) {
HXLINE( 602)									if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 603)										i->set_alpha(( (Float)(0) ));
            									}
            									else {
HXLINE( 604)										if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 605)											i->set_alpha(( (Float)(0) ));
            										}
            										else {
HXLINE( 608)											i->set_alpha(((Float)0.4));
            										}
            									}
            								}
            							}
            						}
HXLINE( 612)						if (this->selectedCat->middle) {
HXLINE( 613)							this->switchCat(this->options->__get(0).StaticCast<  ::OptionCata >(),null());
            						}
            					}
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 619)				{
HXLINE( 620)					{
HXLINE( 620)						 ::Dynamic input = (HX_("wtf we actually did something wrong, but we dont crash bois.\n",f8,f3,9f,3d) + ::Std_obj::string(e));
HXDLIN( 620)						if (::hx::IsNotNull( input )) {
HXLINE( 620)							::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),620,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
HXDLIN( 620)							::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 620)							::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            						}
            					}
HXLINE( 621)					this->selectedCatIndex = 0;
HXLINE( 622)					this->selectedOptionIndex = 0;
HXLINE( 623)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 623)					_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 624)					if (::hx::IsNotNull( this->selectedCat )) {
HXLINE( 626)						{
HXLINE( 626)							int _g = 0;
HXDLIN( 626)							int _g1 = this->selectedCat->options->length;
HXDLIN( 626)							while((_g < _g1)){
HXLINE( 626)								_g = (_g + 1);
HXDLIN( 626)								int i = (_g - 1);
HXLINE( 628)								 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 629)								opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            							}
            						}
HXLINE( 631)						 ::flixel::text::FlxText _hx_tmp = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 631)						_hx_tmp->set_text(this->selectedOption->getValue());
HXLINE( 632)						this->isInCat = true;
            					}
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


 ::OptionsMenu OptionsMenu_obj::instance;

bool OptionsMenu_obj::isInPause;

::Array< int > OptionsMenu_obj::visibleRange;


::hx::ObjectPtr< OptionsMenu_obj > OptionsMenu_obj::__new(::hx::Null< bool >  __o_pauseMenu) {
	::hx::ObjectPtr< OptionsMenu_obj > __this = new OptionsMenu_obj();
	__this->__construct(__o_pauseMenu);
	return __this;
}

::hx::ObjectPtr< OptionsMenu_obj > OptionsMenu_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< bool >  __o_pauseMenu) {
	OptionsMenu_obj *__this = (OptionsMenu_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(OptionsMenu_obj), true, "OptionsMenu"));
	*(void **)__this = OptionsMenu_obj::_hx_vtable;
	__this->__construct(__o_pauseMenu);
	return __this;
}

OptionsMenu_obj::OptionsMenu_obj()
{
}

void OptionsMenu_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(OptionsMenu);
	HX_MARK_MEMBER_NAME(background,"background");
	HX_MARK_MEMBER_NAME(selectedCat,"selectedCat");
	HX_MARK_MEMBER_NAME(selectedOption,"selectedOption");
	HX_MARK_MEMBER_NAME(selectedCatIndex,"selectedCatIndex");
	HX_MARK_MEMBER_NAME(selectedOptionIndex,"selectedOptionIndex");
	HX_MARK_MEMBER_NAME(isInCat,"isInCat");
	HX_MARK_MEMBER_NAME(options,"options");
	HX_MARK_MEMBER_NAME(shownStuff,"shownStuff");
	HX_MARK_MEMBER_NAME(menu,"menu");
	HX_MARK_MEMBER_NAME(descText,"descText");
	HX_MARK_MEMBER_NAME(descBack,"descBack");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void OptionsMenu_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(background,"background");
	HX_VISIT_MEMBER_NAME(selectedCat,"selectedCat");
	HX_VISIT_MEMBER_NAME(selectedOption,"selectedOption");
	HX_VISIT_MEMBER_NAME(selectedCatIndex,"selectedCatIndex");
	HX_VISIT_MEMBER_NAME(selectedOptionIndex,"selectedOptionIndex");
	HX_VISIT_MEMBER_NAME(isInCat,"isInCat");
	HX_VISIT_MEMBER_NAME(options,"options");
	HX_VISIT_MEMBER_NAME(shownStuff,"shownStuff");
	HX_VISIT_MEMBER_NAME(menu,"menu");
	HX_VISIT_MEMBER_NAME(descText,"descText");
	HX_VISIT_MEMBER_NAME(descBack,"descBack");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val OptionsMenu_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"menu") ) { return ::hx::Val( menu ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isInCat") ) { return ::hx::Val( isInCat ); }
		if (HX_FIELD_EQ(inName,"options") ) { return ::hx::Val( options ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { return ::hx::Val( descText ); }
		if (HX_FIELD_EQ(inName,"descBack") ) { return ::hx::Val( descBack ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"switchCat") ) { return ::hx::Val( switchCat_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { return ::hx::Val( background ); }
		if (HX_FIELD_EQ(inName,"shownStuff") ) { return ::hx::Val( shownStuff ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectedCat") ) { return ::hx::Val( selectedCat ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"selectOption") ) { return ::hx::Val( selectOption_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedOption") ) { return ::hx::Val( selectedOption ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"selectedCatIndex") ) { return ::hx::Val( selectedCatIndex ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"selectedOptionIndex") ) { return ::hx::Val( selectedOptionIndex ); }
	}
	return super::__Field(inName,inCallProp);
}

bool OptionsMenu_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { outValue = ( instance ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isInPause") ) { outValue = ( isInPause ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"visibleRange") ) { outValue = ( visibleRange ); return true; }
	}
	return false;
}

::hx::Val OptionsMenu_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"menu") ) { menu=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isInCat") ) { isInCat=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"options") ) { options=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { descText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"descBack") ) { descBack=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { background=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shownStuff") ) { shownStuff=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectedCat") ) { selectedCat=inValue.Cast<  ::OptionCata >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedOption") ) { selectedOption=inValue.Cast<  ::Option >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"selectedCatIndex") ) { selectedCatIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"selectedOptionIndex") ) { selectedOptionIndex=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool OptionsMenu_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { instance=ioValue.Cast<  ::OptionsMenu >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isInPause") ) { isInPause=ioValue.Cast< bool >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"visibleRange") ) { visibleRange=ioValue.Cast< ::Array< int > >(); return true; }
	}
	return false;
}

void OptionsMenu_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("background",ee,93,1d,26));
	outFields->push(HX_("selectedCat",7b,ac,02,30));
	outFields->push(HX_("selectedOption",30,28,d9,ae));
	outFields->push(HX_("selectedCatIndex",97,40,f5,69));
	outFields->push(HX_("selectedOptionIndex",c2,34,59,a7));
	outFields->push(HX_("isInCat",e7,30,81,5a));
	outFields->push(HX_("options",5e,33,fe,df));
	outFields->push(HX_("shownStuff",63,e8,69,47));
	outFields->push(HX_("menu",9f,45,59,48));
	outFields->push(HX_("descText",9e,53,35,f3));
	outFields->push(HX_("descBack",18,61,4c,e7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo OptionsMenu_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(OptionsMenu_obj,background),HX_("background",ee,93,1d,26)},
	{::hx::fsObject /*  ::OptionCata */ ,(int)offsetof(OptionsMenu_obj,selectedCat),HX_("selectedCat",7b,ac,02,30)},
	{::hx::fsObject /*  ::Option */ ,(int)offsetof(OptionsMenu_obj,selectedOption),HX_("selectedOption",30,28,d9,ae)},
	{::hx::fsInt,(int)offsetof(OptionsMenu_obj,selectedCatIndex),HX_("selectedCatIndex",97,40,f5,69)},
	{::hx::fsInt,(int)offsetof(OptionsMenu_obj,selectedOptionIndex),HX_("selectedOptionIndex",c2,34,59,a7)},
	{::hx::fsBool,(int)offsetof(OptionsMenu_obj,isInCat),HX_("isInCat",e7,30,81,5a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(OptionsMenu_obj,options),HX_("options",5e,33,fe,df)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(OptionsMenu_obj,shownStuff),HX_("shownStuff",63,e8,69,47)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(OptionsMenu_obj,menu),HX_("menu",9f,45,59,48)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(OptionsMenu_obj,descText),HX_("descText",9e,53,35,f3)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(OptionsMenu_obj,descBack),HX_("descBack",18,61,4c,e7)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo OptionsMenu_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::OptionsMenu */ ,(void *) &OptionsMenu_obj::instance,HX_("instance",95,1f,e1,59)},
	{::hx::fsBool,(void *) &OptionsMenu_obj::isInPause,HX_("isInPause",07,2a,13,5e)},
	{::hx::fsObject /* ::Array< int > */ ,(void *) &OptionsMenu_obj::visibleRange,HX_("visibleRange",eb,bf,a4,59)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String OptionsMenu_obj_sMemberFields[] = {
	HX_("background",ee,93,1d,26),
	HX_("selectedCat",7b,ac,02,30),
	HX_("selectedOption",30,28,d9,ae),
	HX_("selectedCatIndex",97,40,f5,69),
	HX_("selectedOptionIndex",c2,34,59,a7),
	HX_("isInCat",e7,30,81,5a),
	HX_("options",5e,33,fe,df),
	HX_("shownStuff",63,e8,69,47),
	HX_("menu",9f,45,59,48),
	HX_("descText",9e,53,35,f3),
	HX_("descBack",18,61,4c,e7),
	HX_("create",fc,66,0f,7c),
	HX_("switchCat",82,92,35,0e),
	HX_("selectOption",91,c7,b2,0f),
	HX_("update",09,86,05,87),
	::String(null()) };

static void OptionsMenu_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::instance,"instance");
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::isInPause,"isInPause");
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::visibleRange,"visibleRange");
};

#ifdef HXCPP_VISIT_ALLOCS
static void OptionsMenu_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::instance,"instance");
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::isInPause,"isInPause");
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::visibleRange,"visibleRange");
};

#endif

::hx::Class OptionsMenu_obj::__mClass;

static ::String OptionsMenu_obj_sStaticFields[] = {
	HX_("instance",95,1f,e1,59),
	HX_("isInPause",07,2a,13,5e),
	HX_("visibleRange",eb,bf,a4,59),
	::String(null())
};

void OptionsMenu_obj::__register()
{
	OptionsMenu_obj _hx_dummy;
	OptionsMenu_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("OptionsMenu",fd,43,a3,5d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &OptionsMenu_obj::__GetStatic;
	__mClass->mSetStaticField = &OptionsMenu_obj::__SetStatic;
	__mClass->mMarkFunc = OptionsMenu_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(OptionsMenu_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(OptionsMenu_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< OptionsMenu_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = OptionsMenu_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OptionsMenu_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OptionsMenu_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void OptionsMenu_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_99_boot)
HXDLIN(  99)		isInPause = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_103_boot)
HXDLIN( 103)		visibleRange = ::Array_obj< int >::fromData( _hx_array_data_5da343fd_23,2);
            	}
}

