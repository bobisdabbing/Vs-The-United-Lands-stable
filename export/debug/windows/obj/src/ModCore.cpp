// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Debug
#include <Debug.h>
#endif
#ifndef INCLUDED_ModCore
#include <ModCore.h>
#endif
#ifndef INCLUDED_ModCoreBackend
#include <ModCoreBackend.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_polymod_Framework
#include <polymod/Framework.h>
#endif
#ifndef INCLUDED_polymod_ModMetadata
#include <polymod/ModMetadata.h>
#endif
#ifndef INCLUDED_polymod_Polymod
#include <polymod/Polymod.h>
#endif
#ifndef INCLUDED_polymod_PolymodError
#include <polymod/PolymodError.h>
#endif
#ifndef INCLUDED_polymod_PolymodErrorType
#include <polymod/PolymodErrorType.h>
#endif
#ifndef INCLUDED_polymod_backends_IBackend
#include <polymod/backends/IBackend.h>
#endif
#ifndef INCLUDED_polymod_backends_LimeBackend
#include <polymod/backends/LimeBackend.h>
#endif
#ifndef INCLUDED_polymod_backends_OpenFLBackend
#include <polymod/backends/OpenFLBackend.h>
#endif
#ifndef INCLUDED_polymod_format_ParseRules
#include <polymod/format/ParseRules.h>
#endif
#ifndef INCLUDED_polymod_format_TextFileFormat
#include <polymod/format/TextFileFormat.h>
#endif
#ifndef INCLUDED_polymod_fs_IFileSystem
#include <polymod/fs/IFileSystem.h>
#endif
#ifndef INCLUDED_polymod_util_SemanticVersion
#include <polymod/util/SemanticVersion.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_25_initialize,"ModCore","initialize",0x9a89877d,"ModCore.initialize","ModCore.hx",25,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_36_loadModsById,"ModCore","loadModsById",0xf924ed56,"ModCore.loadModsById","ModCore.hx",36,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_94_getModIds,"ModCore","getModIds",0x0ebea23f,"ModCore.getModIds","ModCore.hx",94,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_103_buildParseRules,"ModCore","buildParseRules",0xf993b645,"ModCore.buildParseRules","ModCore.hx",103,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_115_buildFrameworkParams,"ModCore","buildFrameworkParams",0x3c111743,"ModCore.buildFrameworkParams","ModCore.hx",115,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_127_onPolymodError,"ModCore","onPolymodError",0x11aee05e,"ModCore.onPolymodError","ModCore.hx",127,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_20_boot,"ModCore","boot",0x6a4dca9f,"ModCore.boot","ModCore.hx",20,0xcf163c3d)
HX_LOCAL_STACK_FRAME(_hx_pos_39e2a841ddaa9558_22_boot,"ModCore","boot",0x6a4dca9f,"ModCore.boot","ModCore.hx",22,0xcf163c3d)

void ModCore_obj::__construct() { }

Dynamic ModCore_obj::__CreateEmpty() { return new ModCore_obj; }

void *ModCore_obj::_hx_vtable = 0;

Dynamic ModCore_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ModCore_obj > _hx_result = new ModCore_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ModCore_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x64615661;
}

::String ModCore_obj::API_VERSION;

::String ModCore_obj::MOD_DIRECTORY;

void ModCore_obj::initialize(){
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_25_initialize)
HXLINE(  27)		{
HXLINE(  27)			 ::Dynamic input = HX_("Initializing ModCore...",00,ec,7e,d9);
HXDLIN(  27)			if (::hx::IsNotNull( input )) {
HXLINE(  27)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),27,HX_("ModCore",21,b1,41,a4),HX_("initialize",50,31,bb,ec)));
HXDLIN(  27)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  27)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  28)		::ModCore_obj::loadModsById(::ModCore_obj::getModIds());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(ModCore_obj,initialize,(void))

void ModCore_obj::loadModsById(::Array< ::String > ids){
            	HX_GC_STACKFRAME(&_hx_pos_39e2a841ddaa9558_36_loadModsById)
HXLINE(  37)		{
HXLINE(  37)			 ::Dynamic input = ((HX_("Attempting to load ",40,8e,84,0a) + ids->length) + HX_(" mods...",fd,7c,c7,1c));
HXDLIN(  37)			if (::hx::IsNotNull( input )) {
HXLINE(  37)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),37,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  37)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  37)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  54)		 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  54)		_g->set(HX_("default",c1,d8,c3,9b),HX_("./preload",a8,19,e7,9c));
HXDLIN(  54)		_g->set(HX_("sm",9a,64,00,00),HX_("./sm",1b,df,8b,1e));
HXDLIN(  54)		_g->set(HX_("songs",fe,36,c7,80),HX_("./songs",1d,83,68,c4));
HXDLIN(  54)		_g->set(HX_("shared",a5,5e,2b,1d),HX_("./",41,28,00,00));
HXDLIN(  54)		_g->set(HX_("tutorial",9e,8f,b5,82),HX_("./tutorial",df,60,69,ca));
HXDLIN(  54)		_g->set(HX_("week1",bd,95,be,c7),HX_("./week1",dc,e1,5f,0b));
HXDLIN(  54)		_g->set(HX_("week2",be,95,be,c7),HX_("./week2",dd,e1,5f,0b));
HXDLIN(  54)		_g->set(HX_("week3",bf,95,be,c7),HX_("./week3",de,e1,5f,0b));
HXDLIN(  54)		_g->set(HX_("week4",c0,95,be,c7),HX_("./week4",df,e1,5f,0b));
HXDLIN(  54)		_g->set(HX_("week5",c1,95,be,c7),HX_("./week5",e0,e1,5f,0b));
HXDLIN(  54)		_g->set(HX_("week6",c2,95,be,c7),HX_("./week6",e1,e1,5f,0b));
HXLINE(  61)		::Array< ::String > loadedModList = ::polymod::Polymod_obj::getDefaultIgnoreList();
HXLINE(  64)		 ::polymod::format::ParseRules loadedModList1 = ::ModCore_obj::buildParseRules();
HXLINE(  38)		::Array< ::Dynamic> loadedModList2 = ::polymod::Polymod_obj::init( ::Dynamic(::hx::Anon_obj::Create(9)
            			->setFixed(0,HX_("customBackend",63,24,96,a5),::hx::ClassOf< ::ModCoreBackend >())
            			->setFixed(1,HX_("errorCallback",ad,29,bf,d7),::ModCore_obj::onPolymodError_dyn())
            			->setFixed(2,HX_("modRoot",04,ba,da,e0),::ModCore_obj::MOD_DIRECTORY)
            			->setFixed(3,HX_("apiVersion",9e,39,c9,e5),::ModCore_obj::API_VERSION)
            			->setFixed(4,HX_("parseRules",c4,aa,37,1b),loadedModList1)
            			->setFixed(5,HX_("frameworkParams",64,76,eb,26), ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("assetLibraryPaths",43,04,19,3e),_g)))
            			->setFixed(6,HX_("dirs",86,66,69,42),ids)
            			->setFixed(7,HX_("framework",7e,94,a4,51),::polymod::Framework_obj::CUSTOM_dyn())
            			->setFixed(8,HX_("ignoredFiles",05,36,92,57),loadedModList)));
HXLINE(  67)		{
HXLINE(  67)			 ::Dynamic input1 = ((((HX_("Mod loading complete. We loaded ",d6,ff,4f,ab) + loadedModList2->length) + HX_(" / ",31,71,18,00)) + ids->length) + HX_(" mods.",7d,bb,c3,d7));
HXDLIN(  67)			if (::hx::IsNotNull( input1 )) {
HXLINE(  67)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),67,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  67)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  67)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  69)		{
HXLINE(  69)			int _g1 = 0;
HXDLIN(  69)			while((_g1 < loadedModList2->length)){
HXLINE(  69)				 ::polymod::ModMetadata mod = loadedModList2->__get(_g1).StaticCast<  ::polymod::ModMetadata >();
HXDLIN(  69)				_g1 = (_g1 + 1);
HXLINE(  70)				::String _hx_tmp = ((HX_("  * ",b6,40,3f,15) + mod->title) + HX_(" v",56,1c,00,00));
HXDLIN(  70)				::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(mod->modVersion)) + HX_(" [",3b,1c,00,00));
HXDLIN(  70)				::Debug_obj::logTrace(((_hx_tmp1 + mod->id) + HX_("]",5d,00,00,00)),::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),70,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
            			}
            		}
HXLINE(  72)		::Array< ::String > fileList = ::polymod::Polymod_obj::listModFiles(HX_("IMAGE",3b,57,57,3b));
HXLINE(  73)		{
HXLINE(  73)			 ::Dynamic input2 = ((HX_("Installed mods have replaced ",81,c7,d1,09) + fileList->length) + HX_(" images.",56,94,c2,e7));
HXDLIN(  73)			if (::hx::IsNotNull( input2 )) {
HXLINE(  73)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input2,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),73,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  73)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  73)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  74)		{
HXLINE(  74)			int _g2 = 0;
HXDLIN(  74)			while((_g2 < fileList->length)){
HXLINE(  74)				::String item = fileList->__get(_g2);
HXDLIN(  74)				_g2 = (_g2 + 1);
HXLINE(  75)				::Debug_obj::logTrace((HX_("  * ",b6,40,3f,15) + item),::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),75,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
            			}
            		}
HXLINE(  77)		fileList = ::polymod::Polymod_obj::listModFiles(HX_("TEXT",ad,94,ba,37));
HXLINE(  78)		{
HXLINE(  78)			 ::Dynamic input3 = ((HX_("Installed mods have replaced ",81,c7,d1,09) + fileList->length) + HX_(" text files.",ca,28,f5,fd));
HXDLIN(  78)			if (::hx::IsNotNull( input3 )) {
HXLINE(  78)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input3,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),78,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  78)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  78)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  79)		{
HXLINE(  79)			int _g3 = 0;
HXDLIN(  79)			while((_g3 < fileList->length)){
HXLINE(  79)				::String item = fileList->__get(_g3);
HXDLIN(  79)				_g3 = (_g3 + 1);
HXLINE(  80)				::Debug_obj::logTrace((HX_("  * ",b6,40,3f,15) + item),::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),80,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
            			}
            		}
HXLINE(  82)		fileList = ::polymod::Polymod_obj::listModFiles(HX_("MUSIC",85,08,49,8e));
HXLINE(  83)		{
HXLINE(  83)			 ::Dynamic input4 = ((HX_("Installed mods have replaced ",81,c7,d1,09) + fileList->length) + HX_(" music files.",12,10,0b,59));
HXDLIN(  83)			if (::hx::IsNotNull( input4 )) {
HXLINE(  83)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input4,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),83,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  83)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  83)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  84)		{
HXLINE(  84)			int _g4 = 0;
HXDLIN(  84)			while((_g4 < fileList->length)){
HXLINE(  84)				::String item = fileList->__get(_g4);
HXDLIN(  84)				_g4 = (_g4 + 1);
HXLINE(  85)				::Debug_obj::logTrace((HX_("  * ",b6,40,3f,15) + item),::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),85,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
            			}
            		}
HXLINE(  87)		fileList = ::polymod::Polymod_obj::listModFiles(HX_("SOUND",af,c4,ba,fe));
HXLINE(  88)		{
HXLINE(  88)			 ::Dynamic input5 = ((HX_("Installed mods have replaced ",81,c7,d1,09) + fileList->length) + HX_(" sound files.",28,8d,cf,b6));
HXDLIN(  88)			if (::hx::IsNotNull( input5 )) {
HXLINE(  88)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input5,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),88,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
HXDLIN(  88)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  88)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  89)		{
HXLINE(  89)			int _g5 = 0;
HXDLIN(  89)			while((_g5 < fileList->length)){
HXLINE(  89)				::String item = fileList->__get(_g5);
HXDLIN(  89)				_g5 = (_g5 + 1);
HXLINE(  90)				::Debug_obj::logTrace((HX_("  * ",b6,40,3f,15) + item),::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),90,HX_("ModCore",21,b1,41,a4),HX_("loadModsById",e9,f1,72,7a)));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ModCore_obj,loadModsById,(void))

::Array< ::String > ModCore_obj::getModIds(){
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_94_getModIds)
HXLINE(  95)		{
HXLINE(  95)			 ::Dynamic input = HX_("Scanning the mods folder...",cf,1c,98,a3);
HXDLIN(  95)			if (::hx::IsNotNull( input )) {
HXLINE(  95)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),95,HX_("ModCore",21,b1,41,a4),HX_("getModIds",cc,53,08,3d)));
HXDLIN(  95)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  95)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  96)		::Array< ::Dynamic> modMetadata = ::polymod::Polymod_obj::scan(::ModCore_obj::MOD_DIRECTORY,null(),null(),null());
HXLINE(  97)		{
HXLINE(  97)			 ::Dynamic input1 = ((HX_("Found ",be,6b,1f,34) + modMetadata->length) + HX_(" mods when scanning.",a6,54,a2,95));
HXDLIN(  97)			if (::hx::IsNotNull( input1 )) {
HXLINE(  97)				::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/ModCore.hx",31,04,7b,5b),97,HX_("ModCore",21,b1,41,a4),HX_("getModIds",cc,53,08,3d)));
HXDLIN(  97)				::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN(  97)				::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            			}
            		}
HXLINE(  98)		::Array< ::String > _g = ::Array_obj< ::String >::__new(0);
HXDLIN(  98)		{
HXLINE(  98)			int _g1 = 0;
HXDLIN(  98)			while((_g1 < modMetadata->length)){
HXLINE(  98)				 ::polymod::ModMetadata i = modMetadata->__get(_g1).StaticCast<  ::polymod::ModMetadata >();
HXDLIN(  98)				_g1 = (_g1 + 1);
HXDLIN(  98)				_g->push(i->id);
            			}
            		}
HXDLIN(  98)		::Array< ::String > modIds = _g;
HXLINE(  99)		return modIds;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(ModCore_obj,getModIds,return )

 ::polymod::format::ParseRules ModCore_obj::buildParseRules(){
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_103_buildParseRules)
HXLINE( 104)		 ::polymod::format::ParseRules output = ::polymod::format::ParseRules_obj::getDefault();
HXLINE( 106)		output->addType(HX_("txt",70,6e,58,00),::polymod::format::TextFileFormat_obj::LINES_dyn());
HXLINE( 110)		return output;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(ModCore_obj,buildParseRules,return )

 ::Dynamic ModCore_obj::buildFrameworkParams(){
            	HX_GC_STACKFRAME(&_hx_pos_39e2a841ddaa9558_115_buildFrameworkParams)
HXLINE( 116)		 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 116)		_g->set(HX_("default",c1,d8,c3,9b),HX_("./preload",a8,19,e7,9c));
HXDLIN( 116)		_g->set(HX_("sm",9a,64,00,00),HX_("./sm",1b,df,8b,1e));
HXDLIN( 116)		_g->set(HX_("songs",fe,36,c7,80),HX_("./songs",1d,83,68,c4));
HXDLIN( 116)		_g->set(HX_("shared",a5,5e,2b,1d),HX_("./",41,28,00,00));
HXDLIN( 116)		_g->set(HX_("tutorial",9e,8f,b5,82),HX_("./tutorial",df,60,69,ca));
HXDLIN( 116)		_g->set(HX_("week1",bd,95,be,c7),HX_("./week1",dc,e1,5f,0b));
HXDLIN( 116)		_g->set(HX_("week2",be,95,be,c7),HX_("./week2",dd,e1,5f,0b));
HXDLIN( 116)		_g->set(HX_("week3",bf,95,be,c7),HX_("./week3",de,e1,5f,0b));
HXDLIN( 116)		_g->set(HX_("week4",c0,95,be,c7),HX_("./week4",df,e1,5f,0b));
HXDLIN( 116)		_g->set(HX_("week5",c1,95,be,c7),HX_("./week5",e0,e1,5f,0b));
HXDLIN( 116)		_g->set(HX_("week6",c2,95,be,c7),HX_("./week6",e1,e1,5f,0b));
HXLINE( 115)		return  ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("assetLibraryPaths",43,04,19,3e),_g));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(ModCore_obj,buildFrameworkParams,return )

void ModCore_obj::onPolymodError( ::polymod::PolymodError error){
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_127_onPolymodError)
HXDLIN( 127)		::String _g = error->code;
HXLINE( 147)		switch((int)(error->severity->_hx_getIndex())){
            			case (int)0: {
HXLINE( 150)				 ::Dynamic input = error->message;
HXDLIN( 150)				 ::Dynamic pos = null();
HXDLIN( 150)				if (::hx::IsNotNull( input )) {
HXLINE( 150)					::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,pos);
HXDLIN( 150)					::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_INFO);
HXDLIN( 150)					::Debug_obj::writeToLogFile(output,HX_("INFO",6e,00,7c,30));
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 152)				 ::Dynamic input = error->message;
HXDLIN( 152)				 ::Dynamic pos = null();
HXDLIN( 152)				if (::hx::IsNotNull( input )) {
HXLINE( 152)					::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,pos);
HXDLIN( 152)					::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_WARN);
HXDLIN( 152)					::Debug_obj::writeToLogFile(output,HX_("WARN",46,2a,b3,39));
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 154)				 ::Dynamic input = error->message;
HXDLIN( 154)				 ::Dynamic pos = null();
HXDLIN( 154)				if (::hx::IsNotNull( input )) {
HXLINE( 154)					::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,pos);
HXDLIN( 154)					::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 154)					::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            				}
            			}
            			break;
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ModCore_obj,onPolymodError,(void))


ModCore_obj::ModCore_obj()
{
}

bool ModCore_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"getModIds") ) { outValue = getModIds_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { outValue = initialize_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"API_VERSION") ) { outValue = ( API_VERSION ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"loadModsById") ) { outValue = loadModsById_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"MOD_DIRECTORY") ) { outValue = ( MOD_DIRECTORY ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"onPolymodError") ) { outValue = onPolymodError_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"buildParseRules") ) { outValue = buildParseRules_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"buildFrameworkParams") ) { outValue = buildFrameworkParams_dyn(); return true; }
	}
	return false;
}

bool ModCore_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"API_VERSION") ) { API_VERSION=ioValue.Cast< ::String >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"MOD_DIRECTORY") ) { MOD_DIRECTORY=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ModCore_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ModCore_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &ModCore_obj::API_VERSION,HX_("API_VERSION",f3,b6,13,2d)},
	{::hx::fsString,(void *) &ModCore_obj::MOD_DIRECTORY,HX_("MOD_DIRECTORY",30,ef,4c,e7)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void ModCore_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ModCore_obj::API_VERSION,"API_VERSION");
	HX_MARK_MEMBER_NAME(ModCore_obj::MOD_DIRECTORY,"MOD_DIRECTORY");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ModCore_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ModCore_obj::API_VERSION,"API_VERSION");
	HX_VISIT_MEMBER_NAME(ModCore_obj::MOD_DIRECTORY,"MOD_DIRECTORY");
};

#endif

::hx::Class ModCore_obj::__mClass;

static ::String ModCore_obj_sStaticFields[] = {
	HX_("API_VERSION",f3,b6,13,2d),
	HX_("MOD_DIRECTORY",30,ef,4c,e7),
	HX_("initialize",50,31,bb,ec),
	HX_("loadModsById",e9,f1,72,7a),
	HX_("getModIds",cc,53,08,3d),
	HX_("buildParseRules",92,8f,0a,c3),
	HX_("buildFrameworkParams",d6,66,a2,a1),
	HX_("onPolymodError",b1,6f,f5,05),
	::String(null())
};

void ModCore_obj::__register()
{
	ModCore_obj _hx_dummy;
	ModCore_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("ModCore",21,b1,41,a4);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ModCore_obj::__GetStatic;
	__mClass->mSetStaticField = &ModCore_obj::__SetStatic;
	__mClass->mMarkFunc = ModCore_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ModCore_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ModCore_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ModCore_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ModCore_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ModCore_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ModCore_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_20_boot)
HXDLIN(  20)		API_VERSION = HX_("0.1.0",75,ff,c8,c1);
            	}
{
            	HX_STACKFRAME(&_hx_pos_39e2a841ddaa9558_22_boot)
HXDLIN(  22)		MOD_DIRECTORY = HX_("mods",71,d3,60,48);
            	}
}

